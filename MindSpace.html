<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindSpace - 3D Thought Organization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1000;
            pointer-events: none;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
            pointer-events: auto;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
        }

        .control-group {
            margin-bottom: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .priority-buttons {
            display: flex;
            gap: 5px;
        }

        .priority-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: opacity 0.2s;
        }

        .priority-btn:hover {
            opacity: 0.8;
        }

        .priority-btn.urgent {
            background: #ff4444;
            color: white;
        }

        .priority-btn.medium {
            background: #ffaa00;
            color: white;
        }

        .priority-btn.low {
            background: #44ff44;
            color: black;
        }

        #nodeModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #333;
            min-width: 300px;
            pointer-events: auto;
            display: none;
        }

        #nodeModal input, #nodeModal textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #555;
            border-radius: 4px;
            background: #222;
            color: white;
            font-family: inherit;
        }

        #nodeModal button {
            padding: 8px 16px;
            margin: 5px 5px 0 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-save {
            background: #4CAF50;
            color: white;
        }

        .btn-delete {
            background: #f44336;
            color: white;
        }

        .btn-cancel {
            background: #666;
            color: white;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="instructions">
                <h3>MindSpace Controls</h3>
                <p><strong>Movement:</strong></p>
                <ul>
                    <li>WASD: Move forward/back/left/right</li>
                    <li>Mouse: Look around (click to lock)</li>
                    <li>Arrow Keys: Look around</li>
                    <li>Shift: Move faster</li>
                    <li>Space: Move up</li>
                    <li>C: Move down</li>
                </ul>
                <p><strong>Nodes:</strong></p>
                <ul>
                    <li>Click node buttons below to add</li>
                    <li>Click on nodes to edit</li>
                    <li>Right-click to remove</li>
                </ul>
            </div>

            <div id="controls">
                <div class="control-group">
                    <label>Add Thought Node:</label>
                    <div class="priority-buttons">
                        <button class="priority-btn urgent" onclick="addNode('urgent')">Urgent</button>
                        <button class="priority-btn medium" onclick="addNode('medium')">Medium</button>
                        <button class="priority-btn low" onclick="addNode('low')">Low Priority</button>
                    </div>
                </div>
            </div>

            <div id="stats">
                <div>Nodes: <span id="nodeCount">0</span></div>
                <div>Position: <span id="position">0, 0, 0</span></div>
            </div>

            <div id="crosshair"></div>
        </div>

        <div id="nodeModal">
            <h3>Edit Thought Node</h3>
            <input type="text" id="nodeTitle" placeholder="Node title...">
            <textarea id="nodeContent" rows="4" placeholder="Detailed thoughts..."></textarea>
            <div>
                <button class="btn-save" onclick="saveNode()">Save</button>
                <button class="btn-delete" onclick="deleteNode()">Delete</button>
                <button class="btn-cancel" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ===============================
        // GLOBAL VARIABLES
        // ===============================
        
        let scene, camera, renderer, controls;
        let nodes = []; // Array to store all thought nodes
        let currentNodeId = null; // For editing
        let nodeIdCounter = 0; // For unique IDs
        
        // Movement variables
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        // Mouse controls
        let isMouseLocked = false;
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let PI_2 = Math.PI / 2;
        
        // Raycaster for node interaction
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // ===============================
        // INITIALIZATION
        // ===============================
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011); // Dark blue void
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add ambient lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create infinite grid floor
            createInfiniteGrid();
            
            // Create floating particles for atmosphere
            createFloatingParticles();
            
            // Setup controls
            setupControls();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start render loop
            animate();
            
            console.log('MindSpace initialized successfully!');
        }
        
        // ===============================
        // ENVIRONMENT CREATION
        // ===============================
        
        function createInfiniteGrid() {
            // Create a large grid that extends beyond view
            const gridSize = 1000;
            const gridDivisions = 100;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x333333, 0x222222);
            gridHelper.position.y = 0;
            scene.add(gridHelper);
            
            // Add a subtle fog for depth
            scene.fog = new THREE.Fog(0x000011, 50, 200);
        }
        
        function createFloatingParticles() {
            // Create floating particles for atmosphere
            const particleCount = 500;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 400;     // x
                positions[i + 1] = Math.random() * 100;         // y
                positions[i + 2] = (Math.random() - 0.5) * 400; // z
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x888888,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        // ===============================
        // NODE MANAGEMENT
        // ===============================
        
        function addNode(priority) {
            const nodeId = nodeIdCounter++;
            
            // Create node object
            const nodeData = {
                id: nodeId,
                title: 'New Thought',
                content: '',
                priority: priority,
                position: {
                    x: camera.position.x + Math.random() * 10 - 5,
                    y: camera.position.y + Math.random() * 5,
                    z: camera.position.z - 10 + Math.random() * 5
                }
            };
            
            // Create 3D visual representation
            const nodeVisual = createNodeVisual(nodeData);
            nodeData.visual = nodeVisual;
            
            // Add to scene and array
            scene.add(nodeVisual);
            nodes.push(nodeData);
            
            // Update UI
            updateStats();
            
            // Automatically open edit modal for new nodes
            editNode(nodeId);
            
            console.log('Added node:', nodeData);
        }
        
        function createNodeVisual(nodeData) {
            // Create a group to hold all node elements
            const nodeGroup = new THREE.Group();
            
            // Choose color based on priority
            let color;
            switch(nodeData.priority) {
                case 'urgent': color = 0xff4444; break;
                case 'medium': color = 0xffaa00; break;
                case 'low': color = 0x44ff44; break;
                default: color = 0x888888;
            }
            
            // Create main sphere
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            nodeGroup.add(sphere);
            
            // Create glow effect
            const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.2
            });
            const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            nodeGroup.add(glowSphere);
            
            // Create text label (simplified - using a plane with text texture)
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(nodeData.title, 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const labelGeometry = new THREE.PlaneGeometry(4, 1);
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.y = 1.5;
            nodeGroup.add(label);
            
            // Position the entire group
            nodeGroup.position.set(
                nodeData.position.x,
                nodeData.position.y,
                nodeData.position.z
            );
            
            // Store reference to node data
            nodeGroup.userData = { nodeId: nodeData.id };
            
            return nodeGroup;
        }
        
        function updateNodeVisual(nodeData) {
            // Update the text label
            const label = nodeData.visual.children[2]; // Label is the third child
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(nodeData.title, 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            label.material.map = texture;
            label.material.needsUpdate = true;
        }
        
        function editNode(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            currentNodeId = nodeId;
            
            // Populate modal with node data
            document.getElementById('nodeTitle').value = node.title;
            document.getElementById('nodeContent').value = node.content;
            
            // Show modal
            document.getElementById('nodeModal').style.display = 'block';
        }
        
        function saveNode() {
            if (currentNodeId === null) return;
            
            const node = nodes.find(n => n.id === currentNodeId);
            if (!node) return;
            
            // Update node data
            node.title = document.getElementById('nodeTitle').value || 'Untitled';
            node.content = document.getElementById('nodeContent').value || '';
            
            // Update visual representation
            updateNodeVisual(node);
            
            // Close modal
            closeModal();
            
            console.log('Saved node:', node);
        }
        
        function deleteNode() {
            if (currentNodeId === null) return;
            
            const nodeIndex = nodes.findIndex(n => n.id === currentNodeId);
            if (nodeIndex === -1) return;
            
            const node = nodes[nodeIndex];
            
            // Remove from scene
            scene.remove(node.visual);
            
            // Remove from array
            nodes.splice(nodeIndex, 1);
            
            // Update UI
            updateStats();
            
            // Close modal
            closeModal();
            
            console.log('Deleted node:', currentNodeId);
        }
        
        function closeModal() {
            document.getElementById('nodeModal').style.display = 'none';
            currentNodeId = null;
        }
        
        // ===============================
        // CONTROLS AND INTERACTION
        // ===============================
        
        function setupControls() {
            // Mouse controls for looking around
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onMouseClick);
            document.addEventListener('contextmenu', onRightClick);
            
            // Keyboard controls
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Arrow keys for looking around
            document.addEventListener('keydown', onArrowKeyDown);
            
            // Request pointer lock when clicking on renderer
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
            
            // Handle pointer lock changes
            document.addEventListener('pointerlockchange', () => {
                isMouseLocked = document.pointerLockElement === renderer.domElement;
            });
        }
        
        function onArrowKeyDown(event) {
            const lookSpeed = 0.05;
            
            switch (event.code) {
                case 'ArrowUp':
                    euler.setFromQuaternion(camera.quaternion);
                    euler.x += lookSpeed;
                    euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                    camera.quaternion.setFromEuler(euler);
                    event.preventDefault();
                    break;
                case 'ArrowDown':
                    euler.setFromQuaternion(camera.quaternion);
                    euler.x -= lookSpeed;
                    euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                    camera.quaternion.setFromEuler(euler);
                    event.preventDefault();
                    break;
                case 'ArrowLeft':
                    euler.setFromQuaternion(camera.quaternion);
                    euler.y += lookSpeed;
                    camera.quaternion.setFromEuler(euler);
                    event.preventDefault();
                    break;
                case 'ArrowRight':
                    euler.setFromQuaternion(camera.quaternion);
                    euler.y -= lookSpeed;
                    camera.quaternion.setFromEuler(euler);
                    event.preventDefault();
                    break;
            }
        }
        
        function onMouseMove(event) {
            if (!isMouseLocked) return;
            
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
            
            camera.quaternion.setFromEuler(euler);
        }
        
        function onMouseClick(event) {
            if (isMouseLocked) return;
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections with nodes
            const nodeVisuals = nodes.map(n => n.visual);
            const intersects = raycaster.intersectObjects(nodeVisuals, true);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object.parent;
                if (clickedObject.userData && clickedObject.userData.nodeId !== undefined) {
                    editNode(clickedObject.userData.nodeId);
                }
            }
        }
        
        function onRightClick(event) {
            event.preventDefault();
            
            if (isMouseLocked) return;
            
            // Calculate mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Cast ray from camera
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections with nodes
            const nodeVisuals = nodes.map(n => n.visual);
            const intersects = raycaster.intersectObjects(nodeVisuals, true);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object.parent;
                if (clickedObject.userData && clickedObject.userData.nodeId !== undefined) {
                    // Remove the node
                    const nodeIndex = nodes.findIndex(n => n.id === clickedObject.userData.nodeId);
                    if (nodeIndex !== -1) {
                        scene.remove(nodes[nodeIndex].visual);
                        nodes.splice(nodeIndex, 1);
                        updateStats();
                    }
                }
            }
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    moveUp = true;
                    break;
                case 'KeyC':
                    moveDown = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'Space':
                    moveUp = false;
                    break;
                case 'KeyC':
                    moveDown = false;
                    break;
            }
        }
        
        // ===============================
        // MOVEMENT AND ANIMATION
        // ===============================
        
        function updateMovement(delta) {
            // Get speed multiplier (faster with shift)
            const speedMultiplier = event && event.shiftKey ? 3 : 1;
            const speed = 50 * speedMultiplier;
            
            // Update velocity based on input
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= velocity.y * 10.0 * delta;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.y = Number(moveUp) - Number(moveDown);
            direction.normalize();
            
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            if (moveUp || moveDown) velocity.y += direction.y * speed * delta;
            
            // Apply movement with correct direction vectors
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            
            const up = new THREE.Vector3(0, 1, 0);
            
            // Fixed movement directions - forward/backward based on camera facing
            camera.position.add(forward.multiplyScalar(-velocity.z * delta));
            camera.position.add(right.multiplyScalar(-velocity.x * delta));
            camera.position.add(up.multiplyScalar(velocity.y * delta));
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = 0.016; // Approximately 60 FPS
            
            // Update movement
            updateMovement(delta);
            
            // Update floating animation for nodes
            nodes.forEach(node => {
                if (node.visual) {
                    node.visual.rotation.y += 0.01;
                    node.visual.position.y += Math.sin(Date.now() * 0.001 + node.id) * 0.003;
                }
            });
            
            // Update UI
            updateStats();
            
            // Render
            renderer.render(scene, camera);
        }
        
        // ===============================
        // UI UPDATES
        // ===============================
        
        function updateStats() {
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('position').textContent = 
                `${Math.round(camera.position.x)}, ${Math.round(camera.position.y)}, ${Math.round(camera.position.z)}`;
        }
        
        // ===============================
        // EVENT LISTENERS
        // ===============================
        
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Prevent context menu on right click
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // ===============================
        // INITIALIZATION CALL
        // ===============================
        
        // Initialize the application when the page loads
        window.addEventListener('load', init);
        
        // Make functions available globally for button clicks
        window.addNode = addNode;
        window.saveNode = saveNode;
        window.deleteNode = deleteNode;
        window.closeModal = closeModal;
        
    </script>
</body>
</html>